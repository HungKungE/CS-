## Rust

1. 메모리 영역

1) 스택
- 함수 호출과 관련된 정적인 데이터 저장 영역
- 지역변수, 함수의 매개변수, 반환 주소 등이 저장됨.
- 고정된 크기의 데이터만을 저장. 데이터 생성, 소멸이 빠름, 유연성이 제한적임.

2) 힙
- 동적으로 할당된 데이터 저장 영역
- 개발자가 명시적으로 해제 or GC로 처리해야함. -> Rust는 소유권 덕분에 그런거 없슴^^
- 메모리 할당 및 해제가 스택보다 느림.

3) 데이터
- 프로그램의 전역 변수와 정적 변수를 저장하는 정적인 영역.
- 프로그램 종료 시 까지 유지됨.
- 수정이 불가능한 데이터. 메모리 주소 고정.

2. 특징

1) 소유권 ( OwnerShip )

> 모든 값은 owner라는 변수를 가짐.
> 한 시점에서 하나의 owner만 존재 가능.
> owner가 scope에서 벗어나면 값이 제거됨
> 이를 통해서 갈비지 컬렉터를 쓰지 않고도 메모리 누수를 피할 수 있음.
> 또한 변수가 스코프를 벗어나면 자동으로 소멸함.
> 또한 rust는 데이터를 깊게 복사하지 않음,

2) 빌리기 ( Borrowing )

> 변수를 참조하는 것. 이를 빌린다고 표현하는데,
> 참조자의 수명은 소유자의 수명을 넘을 수 없음.
> 데이터 무결성을 보호함.

3) 수명 ( LifeTime )

> 참조자가 유효한 범위를 나타냄.

- 'static 수명 : 프로그램의 시작부터 종료까지 메모리에 유지되는 데이터의 수명.
- 'a 수명 : 개별적인 함수의 범위에서 해당 함수의 호출 동안 유효한 수명.
- 'b 수명 : 함수 내부의 블록이나 특정 범위에서만 유효한 수명.

```sh
const global_var : i16 = 3; // static 수명의 전역변수

fn main(){
    // 이 함수 안의 변수들은 a 수명
    let a;

    { // 이 scope 안의 변수들은 b 수명
        let b = 2;
        a = &b; // 컴파일 정상적으로 하려면 a=b 로 바꾸기 ( 직접 복사 )
    }

    println!("a:{}",a);
}
-> 이건 문제 있는 코드임
-> b의 수명 < a의 수명 
-> a보다 수명이 짧은 b를 참조해서 컴파일 오류
```

3. Error Handling

1) Result
성공과 실패값을 가짐 -> 함수에서 에러 반환할때 사용

2) Option
값을 가지거나 안가진 상태를 나타냄. -> Some, None이 있음

3) Panic
프로그램의 비정상적인 종료를 유발하는 에러.
</br>
unwrap()은 Result or Option 값을 추출하는데
</br>
Result -> 실패 or Option -> None 이면 Panic을 일으킴

4) match & if let
Result or Option의 값에 따라 처리할 수 있음.
